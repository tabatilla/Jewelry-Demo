<!DOCTYPE html>
<html>
  <head>
    <style>
      body {
        margin: 0;
        height: 100vh;
      }

      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/105/three.min.js"></script>
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/2.1.3/TweenMax.min.js"></script> -->
    <script src="js/OrbitControls.js"></script>
    <script>
      const PIXEL_SIZE = 24;
      const TRAY_WIDTH = 23;
      const TRAY_HEIGHT = 17;
      const ANCHO_BORDE_LATERAL = 15;

      var geometries = [];

      var scene = new THREE.Scene();
      var camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        5000
      );
      camera.position.set(TRAY_WIDTH / 2, TRAY_HEIGHT / 2, 500);

      var renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setClearColor("#E9E0D0");
      renderer.setSize(window.innerWidth, window.innerHeight);

      document.body.appendChild(renderer.domElement);

      window.addEventListener("resize", () => {
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth / window.innerHeight;

        camera.updateProjectionMatrix();
      });

      //Controls
      var controls = new THREE.OrbitControls(camera);
      controls.rotateSpeed = 1.0;
      controls.zoomSpeed = 1.2;
      controls.panSpeed = 0.8;

      //Scene
      scene = new THREE.Scene();

      // Helpers
      //axes = new THREE.AxisHelper(50);
      helper = new THREE.GridHelper(1000, 10);
      //helper.setColors(0x0000ff, 0x808080);
      //scene.add(axes);
      //scene.add(helper);

      ////////////// 3D Element ///////////////
      //   var geometry = new THREE.SphereGeometry(1, 15, 70);
      //   var material = new THREE.MeshLambertMaterial({ color: 0xffcc00 });
      //   var mesh = new THREE.Mesh(geometry, material);

      // var geometry = new THREE.BoxGeometry(100, 100, 100);
      // var material = new THREE.MeshLambertMaterial({ color: 0xffcc00 });
      // var mesh = new THREE.Mesh(geometry, material);

      // mesh.position.set(0, 0, 0);

      //scene.add(mesh);

      //Creación Joyero
      var materialFondo = new THREE.MeshLambertMaterial({
        color: 0xffffff,
        side: THREE.DoubleSide
      });

      var materialBorde = new THREE.MeshLambertMaterial({
        color: 0xffcc00,
        side: THREE.DoubleSide
      });

      //FONDO
      var fondoGeometry = new THREE.PlaneGeometry(
        PIXEL_SIZE * TRAY_WIDTH,
        PIXEL_SIZE * TRAY_HEIGHT
      );

      var fondo = new THREE.Mesh(fondoGeometry, materialFondo);
      fondo.position.set(
        (PIXEL_SIZE * TRAY_WIDTH) / 2,
        (PIXEL_SIZE * TRAY_HEIGHT) / 2,
        -11
      );
      scene.add(fondo);

      crearMarco(
        TRAY_WIDTH / 2,
        TRAY_HEIGHT / 2,
        TRAY_WIDTH,
        TRAY_HEIGHT,
        0.5,
        20
      );

      var celdas = [
        { x: 12, y: 0, w: 4, h: 14 },
        { x: 0, y: 0, w: 12, h: 6 },
        { x: 0, y: 6, w: 12, h: 6 },
        { x: 16, y: 0, w: 7, h: 17 },
        { x: 0, y: 12, w: 12, h: 5 },
        { x: 12, y: 14, w: 4, h: 3 }
      ];

      for (let i = 0; i < celdas.length; i++) {
        crearMarco(
          celdas[i].x + celdas[i].w / 2,
          celdas[i].y + celdas[i].h / 2,
          celdas[i].w,
          celdas[i].h,
          0.2,
          20
        );
      }

      //Creación de Bordes Laterales

      ///////////////////////////////////

      // var bordeLadosGeometry = new THREE.BoxGeometry(20, 300, 20);
      // var bordeSuperioresGeometry = new THREE.BoxGeometry(700, 20, 20);

      // var borde1 = new THREE.Mesh(bordeLadosGeometry, materialBorde);
      // var borde2 = new THREE.Mesh(bordeLadosGeometry, materialBorde);
      // borde1.position.set(340, 0, -11);
      // borde2.position.set(-340, 0, -11);

      // scene.add(borde1);
      // scene.add(borde2);

      // var borde3 = new THREE.Mesh(bordeSuperioresGeometry, materialBorde);
      // var borde4 = new THREE.Mesh(bordeSuperioresGeometry, materialBorde);
      // borde3.position.set(0, 140, -11);
      // borde4.position.set(0, -140, -11);

      // scene.add(borde3);
      // scene.add(borde4);

      // var bordeInternoGeometry = new THREE.BoxGeometry(10, 300, 20);
      // var bordeInterno2Geometry = new THREE.BoxGeometry(700, 10, 20);
      // var borde5 = new THREE.Mesh(bordeInternoGeometry, materialBorde);
      // var borde6 = new THREE.Mesh(bordeInterno2Geometry, materialBorde);
      // var borde7 = new THREE.Mesh(bordeInternoGeometry, materialBorde);

      // borde5.position.set(0, 0, -11);
      // borde6.position.set(0, 0, -11);
      // borde7.position.set(125, 0, -11);
      // scene.add(borde5);
      // scene.add(borde6);
      // scene.add(borde7);

      ///////////////////////////////////

      // var light = new THREE.PointLight(0xff0000, 1, 50);
      // light.position.set(1000, 0, 25);
      // scene.add(light);

      var light = new THREE.HemisphereLight(0xffbf67, 0x15c6ff);
      scene.add(light);

      var render = () => {
        requestAnimationFrame(render);

        //mesh.rotation.x += 0.01;

        renderer.render(scene, camera);
        controls.update();
      };

      render();

      //Animaciones con otra librería
      // this.tl = new TimelineMax().delay(0.3);
      // this.tl.to(this.mesh.scale, 1, { x: 2, ease: Expo.easeOut });
      // this.tl.to(this.mesh.scale, 0.5, { x: 0.5, ease: Expo.easeOut });
      // this.tl.to(this.mesh.position, 0.5, { x: 2, ease: Expo.easeOut });
      // this.tl.to(this.mesh.rotation, 0.5, {
      //   y: Math.PI * 0.5,
      //   ease: Expo.easeOut
      // });

      function crearMarco(x, y, w, h, anchoBorde, profundidad) {
        var BordesVerticalesGeometry = new THREE.BoxGeometry(
          anchoBorde * PIXEL_SIZE,
          PIXEL_SIZE * h,
          profundidad
        );
        var BordesHorizontalesGeometry = new THREE.BoxGeometry(
          PIXEL_SIZE * w,
          anchoBorde * PIXEL_SIZE,
          profundidad
        );

        var bordeIzq = new THREE.Mesh(BordesVerticalesGeometry, materialBorde);
        var bordeDer = new THREE.Mesh(BordesVerticalesGeometry, materialBorde);
        var bordeSup = new THREE.Mesh(
          BordesHorizontalesGeometry,
          materialBorde
        );
        var bordeInf = new THREE.Mesh(
          BordesHorizontalesGeometry,
          materialBorde
        );

        bordeIzq.position.set(
          (x - w / 2 + anchoBorde / 2) * PIXEL_SIZE,
          y * PIXEL_SIZE,
          0
        );
        bordeDer.position.set(
          (x + w / 2 - anchoBorde / 2) * PIXEL_SIZE,
          y * PIXEL_SIZE,
          0
        );
        bordeSup.position.set(
          x * PIXEL_SIZE,
          (y + h / 2 - anchoBorde / 2) * PIXEL_SIZE,
          0
        );
        bordeInf.position.set(
          x * PIXEL_SIZE,
          (y - h / 2 + anchoBorde / 2) * PIXEL_SIZE,
          0
        );

        scene.add(bordeIzq);
        scene.add(bordeDer);
        scene.add(bordeSup);
        scene.add(bordeInf);

        return;
      }
    </script>
  </body>
</html>
